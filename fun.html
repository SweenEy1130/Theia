<head>
<script type="text/javascript" src = "math.min.js"></script>
<!--shades-->
<script id="shader-vs" type="x-shader/x-vertex">
attribute vec2 cVertex;//quad vetices
varying vec3 dir;//eye ray direction
uniform float fov;//field of view, camera param
uniform float ratio;//xres/yres
uniform mat3 rtrans;//translate eye ray from camera space to world space

float fov_factor = tan( radians( fov /2.0) ) ;

void main(void) {
	
	gl_Position =  vec4(cVertex, 0, 1.0);
	dir = rtrans * vec3( cVertex.x * fov_factor * ratio, cVertex.y * fov_factor, 1);//generate eye ray
}
</script>

<script id="shader-fs" type="x-shader/x-fragment">
precision mediump float;
//data structures
struct Ray{
	vec3 dir;
	vec3 origin;
};
struct Sphere{
	vec3 pos;
	float rad;
};
struct Box{
	vec3 min;
	vec3 max;
};
struct Light{
	vec3 posOrDir;//positional light use pos while directional light use direction
	bool isDirectional;
	vec3 Is;//specular intensity
	vec3 Id;//diffuse intensity
};

uniform vec3 rot, rotv;//motion blur speed
uniform vec3 cameraPos;//camera position
uniform sampler2D texture_wall;
varying vec3 dir;//eye ray direction
//const setting
const int bounce = 3;//max bounce time
const float epsilon = 0.001;//tolerance
const int X = 0, Y = 1, Z = 2;
//temporal vars
const Sphere sphere1 = Sphere(vec3(0, 0, 0), 1.);
const Light light1 = Light(vec3(-8, 8, -2), false, vec3(1.), vec3(1.));
const Box room = Box(vec3(-10, -10, -20), vec3(10, 10, 20));

//some uti
mat3 getRotMat(float degree, int choice){
	float rad = radians(degree);
	if(choice == X)
		return 	mat3(1, 0, 0, 0, cos(rad), -sin(rad), 0, sin(rad), cos(rad));
	else if ( choice == Y )
		return mat3(cos(rad), 0, sin(rad), 0, 1, 0, -sin(rad), 0, cos(rad));
	else return mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);
}

bool intersectBox(Ray eyeRay,Box box, out float dist){//ray box intersect
	vec3 tMin = (box.min - eyeRay.origin) / eyeRay.dir;
	vec3 tMax = (box.max - eyeRay.origin) / eyeRay.dir;
	vec3 t1 = min(tMin, tMax);
	vec3 t2 = max(tMin, tMax);
	float tNear = max(max(t1.x, t1.y), t1.z);
	float tFar = min(min(t2.x, t2.y), t2.z);
	dist = tFar;
	if(tNear <= tFar && tFar >= 0.)
		return true;
	return false;
}

vec3 normalForBox(vec3 hit, Box box){
	if(hit.x < box.min.x + epsilon ) return vec3(-1.0, 0.0, 0.0);//box left
	else if(hit.x > box.max.x -  epsilon) return vec3(1.0, 0.0, 0.0);//box right
	else if(hit.y < box.min.y +  epsilon ) return vec3(0.0, -1.0, 0.0);//box bottom
	else if(hit.y > box.max.y - epsilon) return vec3(0.0, 1.0, 0.0);//box top
	else if(hit.z < box.min.z + epsilon ) return vec3(0.0, 0.0, -1.0);//box front
	else return vec3(0.0, 0.0, 1.0);//box back
	return vec3(0.0, 0.0, 1.0);
}

bool intersectSphere(Sphere sphere, Ray eyeRay, out float dist) {
	vec3 c = sphere.pos - eyeRay.origin;
	float b = dot(eyeRay.dir, c);
	if(b < 0.0)
	return false;
	float d = dot(c, c) - b*b;
	if(d < 0.0 || d > sphere.rad * sphere.rad)
	return false;
	dist = b- sqrt(sphere.rad * sphere.rad- d);
	return true;
}

vec3 ambient(vec3 color){
	return color;
}
vec3 diffuse(vec3 L, vec3 N, vec3 Id){
	return dot(L, N) * Id;
}
vec3 specular(vec3 L, vec3 N, vec3 V, vec3 Is){
	vec3 R = reflect(L, N);
	return pow(max(dot(R, V), 0.0), 30.0) * Is;
}

//simple map test !!!
vec2 mapfoo(vec3 pos){
	pos.x = 0.0;//no use
	pos.y /= room.max.y - room.min.y;
	pos.z /= room.max.z - room.min.z;
	pos += 0.5;
	pos.y = 1.0 - pos.y;
	return pos.yz;
}

vec3 lightAt(vec3 hit, vec3 N, vec3 V, int obj)//calculate light at a object point
{
	//vec3 L = lightSource;
	vec3 ka = vec3(0.3), ks = vec3(0.4), kd = vec3(0.3);
	vec3 L = normalize(light1.posOrDir - hit);//use point light
	vec3 R = reflect(L, N);
	vec3 c = vec3(0);
	vec2 uv;
	if(obj == 0)
	kd = ka = vec3(0, 0, 0.5);
	else if(abs(N.x) == 1.0)
		kd = ka = texture2D(texture_wall, mapfoo(hit)).xyz;
	else if(N.y == 1.0)
		{ks = ka = vec3(1); kd = vec3(0);}
	else
		kd = ka = vec3(0.5, 0, 0);

	c += ambient(vec3(0.2)) * ka;

	float dist;
    
    Ray shadowRay = Ray(normalize(light1.posOrDir - hit), hit);

	//shadow
	if(intersectSphere(sphere1,shadowRay, dist)  && dist > 0.)//intersect any object, blocked
		return c;
	c += diffuse(L, N, light1.Id )* kd;
	c += specular(L, N, V, light1.Is )*  ks;

	return c;
}

vec3 intersect(Ray eyeRay){//main ray bounce function
	vec3 color = vec3(0),ncolor, norm, hit, stoLight;
	vec3 dl, al, sl;
	vec2 roomHits;
	bool stop = false;
	float dist;
	
	for(int i = 0; i < bounce; i++){
		if(stop)
			break;
		if(intersectSphere(sphere1, eyeRay, dist)){
			hit = eyeRay.origin + dist * eyeRay.dir;
			norm = normalize(hit - sphere1.pos);
			ncolor = lightAt(hit, norm, eyeRay.dir, 0);
			stop = false;
		}
		else{//intersect wall somewhere
			if(intersectBox(eyeRay, room, dist)){
				hit = eyeRay.origin + dist * eyeRay.dir;
				norm = normalForBox(hit, room);
				ncolor = lightAt(hit, -norm, eyeRay.dir, 1);//calculate inner color
				stop = hit.y < room.min.y + epsilon ? false : true;//floor reflect
			}
		}
		color = i==0 ? ncolor : color * 0.5 +  ncolor * 0.5;
		//generate new ray
		eyeRay.origin = eyeRay.origin + dist * eyeRay.dir;
		eyeRay.dir = reflect(eyeRay.dir, norm);
	}
	return color;
}

const int SAMPLE_NUM = 6;
void main(void) {
	vec3 cameraDir, color = vec3(0);
	Ray eyeRay;
	float fi;
	for(int i = 0; i < SAMPLE_NUM; ++i){
		fi = float(i) / float(SAMPLE_NUM) / 24.;
		cameraDir = normalize(getRotMat(rot.x + rotv.x * fi , X) * getRotMat(rot.y + rotv.y * fi, Y)  * dir);
		eyeRay = Ray(cameraDir, cameraPos);
		color += intersect(eyeRay) / float(SAMPLE_NUM);		
	}

	gl_FragColor = vec4(color, 1);
}
</script>
<script type = "text/javascript"  src = "fun_uti.js"></script>
<script type = "text/javascript" src = "fun_render.js"></script>
<script type = "text/javascript"  src = "fun_gui.js"></script>
<script type = "text/javascript" src = "fun_main.js"></script>
</script>
</head>
<body>
<canvas id = "canv"></canvas>
</body>
