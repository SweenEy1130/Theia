<!doctype html>
<html lang="en">
	<head>
		<title>Displacement map</title>
		<meta charset="utf-8">
	</head>

	<body>
		<div id="container"></div>
	</body>

	<script src="three.min.js"></script>

	<script type="x-shader/x-vertex" id="vertexShader">
	varying vec3 worldPosition;

	void main(){
		worldPosition = vec3(modelViewMatrix * vec4(position, 1.0));
		gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
	}
	</script>

	<script type="x-shader/x-vertex" id="fragmentShader">
	uniform sampler2D normalSampler;
	uniform sampler2D normalSampler1;
	uniform float time;

	varying vec3 worldPosition;

	vec4 getNoise(vec2 uv){
		vec2 uv0 = (uv/103.0)+vec2(time/17.0, time/29.0);
		vec2 uv1 = uv/107.0-vec2(time/-19.0, time/31.0);
		vec2 uv2 = uv/vec2(89.0, 32.0)+vec2(time/10.0, time/97.0);
		vec2 uv3 = uv/vec2(91.0, 87.0)-vec2(time/109.0, time/-113.0);
		vec4 noise = (texture2D(normalSampler, uv0)) +
					 (texture2D(normalSampler1, uv1)) +
					 (texture2D(normalSampler, uv2)) +
					 (texture2D(normalSampler1, uv3));
		return noise*0.5-1.0;
	}

	void sunLight(const vec3 sunDirection, const vec3 sunColor, const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor){
		vec3 reflection = normalize(reflect(-sunDirection, surfaceNormal));
		float direction = max(0.0, dot(eyeDirection, reflection));
		specularColor += pow(direction, shiny)*sunColor*spec;
		diffuseColor += max(dot(sunDirection, surfaceNormal),0.0)*sunColor*diffuse;
	}

	void main(){
		vec4 noise = getNoise(worldPosition.xz);
		vec3 surfaceNormal = normalize(noise.xzy * vec3(2.0, 1.0, 2.0));

		vec3 diffuse = vec3(0.0);
		vec3 specular = vec3(0.0);

		vec3 worldToEye = vec3(1,0,0) - worldPosition;
		vec3 eyeDirection = normalize(worldToEye);
		sunLight(vec3(0.7,0.7,0.1), vec3(10, 10, 10), surfaceNormal, eyeDirection, 100.0, 10.0, 0.5, diffuse, specular);

		gl_FragColor = vec4((diffuse+specular+vec3(0.1))*vec3(0.3, 0.5, 0.9), 0.5);
	}
	</script>

	<script type="text/javascript" id="mainCode">
		var container,
			renderer,
			scene,
			camera,
			mesh,
			start = Date.now(),
			fov = 30;

		window.addEventListener( 'load', function() {

			// grab the container from the DOM
			container = document.getElementById( "container" );

			// create a scene
			scene = new THREE.Scene();

			// create a camera the size of the browser window
			// and place it 100 units away, looking towards the center of the scene
			camera = new THREE.PerspectiveCamera(
				fov,
				window.innerWidth / window.innerHeight,
				1,
				10000 );
			camera.position.z = 100;
			camera.target = new THREE.Vector3( 0, 0, 0 );
			scene.add( camera );

			// Create a mesh and insert the geometry and the material. Translate the whole mesh
			// by 1.5 on the x axis and by 4 on the z axis and add the mesh to the scene.
			// var squareMesh = new THREE.Mesh(squareGeometry, squareMaterial);
			// squareMesh.position.set(1.5, 0.0, 4.0);
			// scene.add(squareMesh);
			var geometry = new THREE.PlaneBufferGeometry( 50, 50, 1, 1);
			geometry.applyMatrix( new THREE.Matrix4().makeRotationZ(-Math.PI / 4 ) );
			geometry.applyMatrix( new THREE.Matrix4().makeRotationX(-Math.PI / 2.5 ) );
			/*material = new THREE.MeshBasicMaterial( {
				color: 0xb7ff00,
				wireframe: true
			} );*/
			material = new THREE.ShaderMaterial( {
				uniforms: {
					normalSampler: {
						type: "t",
						value: THREE.ImageUtils.loadTexture('2563-normal.jpg' )
					},
					normalSampler1: {
						type: "t",
						value: THREE.ImageUtils.loadTexture('639-normal.jpg' )
					},
					time: { // float initialized to 0
						type: "f",
						value: 0.0
					}
				},
				vertexShader: document.getElementById( 'vertexShader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
			} );

			mesh = new THREE.Mesh(geometry, material);
			scene.add( mesh );

			// Create light
			var light = new THREE.PointLight(0xff00ff, 1.0);
			// We want it to be very close to our character
			light.position.set(0.0,0.0,0.5);
			camera.add(light);
			scene.add(camera);

			// create the renderer and attach it to the DOM
			renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );

			container.appendChild( renderer.domElement );

			render();

		} );

		function render() {
			material.uniforms[ 'time' ].value = .00025 * ( Date.now() - start );

			renderer.render( scene, camera );
			requestAnimationFrame( render );
		}
	</script>

</html>