<head>
<script type="text/javascript" src = "math.min.js"></script>
<!--shades-->
<script id="shader-vs" type="x-shader/x-vertex">
attribute vec2 cVertex;//quad vetices
void main(void) {
	gl_Position =  vec4(cVertex, 0, 1.0);
}
</script>
	
<script id="shader-fs" type="x-shader/x-fragment">
precision mediump float;
//data structures
struct Camera{
	vec3 pos,rotv;
	float fov_factor;//tan( radians( fov /2.0) ) ;
	vec2 res;
};
struct Ray{
	vec3 dir;
	vec3 origin;
};
struct Sphere{
	vec3 pos;
	float rad;
};
struct Box{
	vec3 min;
	vec3 max;
};

const int LIGHT_AREA = 1;
struct Light{
	vec3 posOrDir;//positional light use pos while directional light use direction
	vec3 size;//radius for sphere light
	bool isDirectional;
	int type;//sphere light or area light
	vec3 Is;//specular intensity
	vec3 Id;//diffuse intensity
};

uniform Camera camera;
uniform mat3 trans;
uniform float sampleCount;
uniform sampler2D tex0;
uniform sampler2D tex1;
//const setting
const int BOUNCE = 3;//max bounce time
const float EPSILON = 0.001;//tolerance
const int X = 0, Y = 1, Z = 2;
const int SAMPLE_NUM = 4;
float msample = sqrt(float(SAMPLE_NUM));
float s;//seed for random generator

//temporal vars
const Sphere sphere1 = Sphere(vec3(0, 0, 0), 1.);
const Light light1 = Light(vec3(-10, 9.5, -0.5), vec3(0, 1, 1), false, LIGHT_AREA, vec3(1.), vec3(1.));
const Box room = Box(vec3(-10, -10, -20), vec3(10, 10, 20));

//some uti
mat3 getRotMat(float degree, int choice){
	float rad = radians(degree);
	if(choice == X)
		return 	mat3(1, 0, 0, 0, cos(rad), -sin(rad), 0, sin(rad), cos(rad));
	else if ( choice == Y )
		return mat3(cos(rad), 0, sin(rad), 0, 1, 0, -sin(rad), 0, cos(rad));
	else return mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);
}

//random function from [Antialiasing by Justaway]
void srand(vec2 p){
	s =sin(dot(p,vec2(423.62431,321.54323)));
}
float rand(){
	s=fract(s*32322.65432+0.12333);
	return abs(fract(s));
}

bool intersectBox(Ray eyeRay,Box box, out float dist){//ray box intersect
	vec3 tMin = (box.min - eyeRay.origin) / eyeRay.dir;
	vec3 tMax = (box.max - eyeRay.origin) / eyeRay.dir;
	vec3 t1 = min(tMin, tMax);
	vec3 t2 = max(tMin, tMax);
	float tNear = max(max(t1.x, t1.y), t1.z);
	float tFar = min(min(t2.x, t2.y), t2.z);
	dist = tFar;
	if(tNear <= tFar && tFar >= 0.)
		return true;
	return false;
}

vec3 normalForBox(vec3 hit, Box box){
	if(hit.x < box.min.x + EPSILON ) return vec3(-1.0, 0.0, 0.0);//box left
	else if(hit.x > box.max.x -  EPSILON) return vec3(1.0, 0.0, 0.0);//box right
	else if(hit.y < box.min.y +  EPSILON ) return vec3(0.0, -1.0, 0.0);//box bottom
	else if(hit.y > box.max.y - EPSILON) return vec3(0.0, 1.0, 0.0);//box top
	else if(hit.z < box.min.z + EPSILON ) return vec3(0.0, 0.0, -1.0);//box front
	else return vec3(0.0, 0.0, 1.0);//box back
	return vec3(0.0, 0.0, 1.0);
}

bool intersectSphere(Sphere sphere, Ray eyeRay, out float dist) {
	vec3 c = sphere.pos - eyeRay.origin;
	float b = dot(eyeRay.dir, c);
	if(b < 0.0)
	return false;
	float d = dot(c, c) - b*b;
	if(d < 0.0 || d > sphere.rad * sphere.rad)
	return false;
	dist = b- sqrt(sphere.rad * sphere.rad- d);
	return true;
}

vec3 ambient(vec3 color){
	return color;
}
vec3 diffuse(vec3 L, vec3 N, vec3 Id){
	return dot(L, N) * Id;
}
vec3 specular(vec3 L, vec3 N, vec3 V, vec3 Is){
	vec3 R = reflect(L, N);
	return pow(max(dot(R, V), 0.0), 30.0) * Is;
}

//simple map test !!!
vec2 mapfoo(vec3 pos){
	pos.x = 0.0;//no use
	pos.y /= room.max.y - room.min.y;
	pos.z /= room.max.z - room.min.z;
	pos += 0.5;
	pos.y = 1.0 - pos.y;
	return pos.yz;
}

vec3 lightAt(vec3 hit, vec3 N, vec3 V, int obj)//calculate light at a object point
{
	//vec3 L = lightSource;
	vec3 ka = vec3(0.3), ks = vec3(0.4), kd = vec3(0.3);
	vec3 L = normalize(light1.posOrDir - hit);//use point light
	vec3 R = reflect(L, N);
	vec3 c = vec3(0);
	vec2 uv;
	if(obj == 0)
	kd = ka = vec3(0, 0, 0.5);
	else if(abs(N.x) == 1.0)
		kd = ka = texture2D(tex1, mapfoo(hit)).xyz;
	else if(N.y == 1.0)
		{ks = ka = vec3(1); kd = vec3(0);}
	else
		kd = ka = vec3(0.5, 0, 0);

	c += ambient(vec3(0.2)) * ka;

	float dist;
    
    //shadow
    for(int i = 0; i < SAMPLE_NUM; i++){
    	vec3 grid = light1.size * vec3(float(i) / msample, mod(float(i),msample), 0); 
    	Ray shadowRay = Ray(normalize(light1.posOrDir +  rand()*light1.size * 0.25 - hit), hit);
    	if(intersectSphere(sphere1,shadowRay, dist)  && dist > 0.)//intersect any object, blocked
			continue;
		c += diffuse(L, N, light1.Id )* kd / float(SAMPLE_NUM);
		c += specular(L, N, V, light1.Is )*  ks / float(SAMPLE_NUM);		
    }

	return c;
}

vec3 intersect(Ray eyeRay){//main ray bounce function
	vec3 color = vec3(0),ncolor, norm, hit, stoLight;
	vec3 dl, al, sl;
	vec2 roomHits;
	bool stop = false;
	float dist;
	
	for(int i = 0; i < BOUNCE; i++){
		if(stop)
			break;
		if(intersectSphere(sphere1, eyeRay, dist)){
			hit = eyeRay.origin + dist * eyeRay.dir;
			norm = normalize(hit - sphere1.pos);
			ncolor = lightAt(hit, norm, eyeRay.dir, 0);
			stop = false;
		}
		else{//intersect wall somewhere
			if(intersectBox(eyeRay, room, dist)){
				hit = eyeRay.origin + dist * eyeRay.dir;
				norm = normalForBox(hit, room);
				ncolor = lightAt(hit, -norm, eyeRay.dir, 1);//calculate inner color
				stop = hit.y < room.min.y + EPSILON ? false : true;//floor reflect
			}
		}
		color = i==0 ? ncolor : color * 0.5 +  ncolor * 0.5;
		//generate new ray
		eyeRay.origin = eyeRay.origin + dist * eyeRay.dir;
		eyeRay.dir = reflect(eyeRay.dir, norm);
	}
	return color;
}

vec2 randOffset(float sampleCount){
    sampleCount = mod(sampleCount,float(SAMPLE_NUM));
	vec2 offset = vec2(floor(sampleCount/msample),mod(sampleCount,msample));
	offset += vec2(rand(), rand());
	offset /= msample;
	return offset;
}
void main(void) {
	vec3 color = vec3(0) , pColor;
	vec2 offset;
	//vec2 offset =vec2(0);
	srand(gl_FragCoord.xy + vec2(sampleCount));//feed random generator
	offset = randOffset(sampleCount);
	Ray eyeRay = Ray(trans * vec3((gl_FragCoord.xy+offset-camera.res/2.)/camera.res.yy * camera.fov_factor,1),camera.pos);//fire eye ray
	eyeRay.dir = normalize(eyeRay.dir);
	pColor = texture2D(tex0, gl_FragCoord.xy/camera.res).rgb;
	color = intersect(eyeRay);	
	gl_FragColor = vec4(mix(pColor,color,1./sampleCount), 1);
	//gl_FragColor = vec4(color, 1);
}
</script>
<script type = "text/javascript"  src = "fun_uti.js"></script>
<script type = "text/javascript" src = "fun_render.js"></script>
<script type = "text/javascript"  src = "fun_gui.js"></script>
<script type = "text/javascript" src = "fun_main.js"></script>
</script>
</head>
<body>
<canvas id = "canv"></canvas>
</body>
