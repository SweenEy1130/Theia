<!doctype html>
<html lang="en">
	<head>
		<title>Displacement map</title>
		<meta charset="utf-8">
	</head>

	<body>
		<div id="container"></div>
	</body>

	<script src="three.min.js"></script>

	<script type="x-shader/x-vertex" id="vertexShader">
	varying vec3 worldPosition;
	varying vec2 vUv;

	void main(){
		vUv	= uv;
		worldPosition = vec3(modelViewMatrix * vec4(position, 1.0));
		gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
	}
	</script>

	<script type="x-shader/x-vertex" id="fragmentShader">
	uniform sampler2D normalSampler;
	uniform sampler2D normalSampler1;
	uniform float time;

	varying vec3 worldPosition;
	varying vec2 vUv;

	const vec3 lightPos = vec3(0,0,1.0);
	const vec3 ambientColor = vec3(0.0, 0.3, 0.6);
	const vec3 diffuseColor = vec3(0.0, 0.6, 0.3);
	const vec3 specColor = vec3(1.0, 1.0, 1.0);

	vec4 getNorm(vec2 uv){
		vec2 uv0 = vec2(mod(uv.x + 0.7 * time, 1.0), mod(uv.y + 0.3 * time, 1.0));
		vec2 uv1 = vec2(mod(uv.x + 0.5 * time, 1.0), mod(uv.y - 0.6 * time, 1.0));
		vec4 norm = (texture2D(normalSampler, uv0)+ texture2D(normalSampler1, uv1));

		return norm / 2.0;
	}

	void main(){
		vec4 norm = getNorm(vUv.xy);

		vec3 normal = normalize(norm.xyz);
		vec3 lightDir = normalize(lightPos - worldPosition);
		vec3 reflectDir = reflect(-lightDir, normal);
		vec3 viewDir = normalize(-worldPosition);

		float lambertian = max(dot(lightDir,normal), 0.0);
		float specular = 0.0;

		if(lambertian > 0.0) {
		   float specAngle = max(dot(reflectDir, viewDir), 0.0);
		   specular = pow(specAngle, 4.0);
		}
		gl_FragColor = vec4(ambientColor + lambertian*diffuseColor + 5.0 * specular*specColor, 1.0);
	}
	</script>

	<script type="text/javascript" id="mainCode">
		var container,
			renderer,
			scene,
			camera,
			mesh,
			start = Date.now(),
			fov = 30;

		window.addEventListener( 'load', function() {

			// grab the container from the DOM
			container = document.getElementById( "container" );

			// create a scene
			scene = new THREE.Scene();

			// create a camera the size of the browser window
			// and place it 100 units away, looking towards the center of the scene
			camera = new THREE.PerspectiveCamera(
				fov,
				window.innerWidth / window.innerHeight,
				1,
				10000 );
			camera.position.z = 100;
			camera.target = new THREE.Vector3( 0, 0, 0 );
			scene.add( camera );

			var geometry = new THREE.PlaneBufferGeometry( 50, 50, 1, 1);
			geometry.applyMatrix( new THREE.Matrix4().makeRotationZ(-Math.PI / 4 ) );
			geometry.applyMatrix( new THREE.Matrix4().makeRotationX(-Math.PI / 2.5 ) );

			material = new THREE.ShaderMaterial( {
				uniforms: {
					normalSampler: {
						type: "t",
						value: THREE.ImageUtils.loadTexture('4483-normal.jpg' )
					},
					normalSampler1: {
						type: "t",
						value: THREE.ImageUtils.loadTexture('639-normal.jpg' )
					},
					time: { // float initialized to 0
						type: "f",
						value: 0.0
					}
				},
				vertexShader: document.getElementById( 'vertexShader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
			} );

			mesh = new THREE.Mesh(geometry, material);
			scene.add( mesh );

			// Create light
			var light = new THREE.PointLight(0xff00ff, 1.0);
			// We want it to be very close to our character
			light.position.set(0.0,0.0,0.5);
			camera.add(light);
			scene.add(camera);

			// create the renderer and attach it to the DOM
			renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );

			container.appendChild( renderer.domElement );

			render();

		} );

		function render() {
			material.uniforms[ 'time' ].value = .00025 * ( Date.now() - start );

			renderer.render( scene, camera );
			requestAnimationFrame( render );
		}
	</script>

</html>